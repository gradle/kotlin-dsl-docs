<html><head><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Writing Custom Task Classes - Gradle User Guide Version 4.3-20171005220000+0000</title><link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="base.css"><link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="docs.css"><link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="userguide.css"><meta content="DocBook XSL Stylesheets V1.75.2" name="generator"><link rel="home" href="userguide.html" title="Gradle User Guide Version 4.3-20171005220000+0000"><link rel="up" href="pt04.html" title="Part&nbsp;IV.&nbsp;Extending the build"><link rel="prev" href="pt04.html" title="Part&nbsp;IV.&nbsp;Extending the build"><link rel="next" href="custom_plugins.html" title="Writing Custom Plugins - Gradle User Guide Version 4.3-20171005220000+0000"></head><body><div class="navheader"><div><div class="navbar"><a xmlns:xslthl="http://xslthl.sf.net" href="pt04.html" title="Part&nbsp;IV.&nbsp;Extending the build">Previous</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="userguide.html" title="Gradle User Guide Version 4.3-20171005220000+0000">Contents</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="custom_plugins.html" title="Writing Custom Plugins - Gradle User Guide Version 4.3-20171005220000+0000">Next</a></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 xmlns:xslthl="http://xslthl.sf.net"><a name="custom_tasks"></a>Chapter&nbsp;40.&nbsp;Writing Custom Task Classes</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="custom_tasks.html#sec:packaging_a_task_class">40.1. Packaging a task class</a></span></dt><dt><span class="section"><a href="custom_tasks.html#sec:writing_a_simple_task_class">40.2. Writing a simple task class</a></span></dt><dt><span class="section"><a href="custom_tasks.html#sec:custom_tasks_standalone_project">40.3. A standalone project</a></span></dt><dt><span class="section"><a href="custom_tasks.html#incremental_tasks">40.4. Incremental tasks</a></span></dt><dt><span class="section"><a href="custom_tasks.html#worker_api">40.5. The Worker API</a></span></dt><dt><span class="section"><a href="custom_tasks.html#sec:reusing_task_logic">40.6. Re-using logic between task classes</a></span></dt></dl></div><p>Gradle supports two types of task. One such type is the simple task, where you define the task with an action closure. We have seen these in <a class="xref" href="tutorial_using_tasks.html">Chapter&nbsp;16, <i>Build Script Basics</i></a>. For this type of task, the action closure determines the behaviour of the task. This type of task is good for implementing one-off tasks in your build script.</p><p>The other type of task is the enhanced task, where the behaviour is built into the task, and the task provides some properties which you can use to configure the behaviour. We have seen these in <a class="xref" href="more_about_tasks.html">Chapter&nbsp;19, <i>More about Tasks</i></a>. Most Gradle plugins use enhanced tasks. With enhanced tasks, you don&rsquo;t need to implement the task behaviour as you do with simple tasks. You simply declare the task and configure the task using its properties. In this way, enhanced tasks let you reuse a piece of behaviour in many different places, possibly across different builds.</p><p>The behaviour and properties of an enhanced task is defined by the task&rsquo;s class. When you declare an enhanced task, you specify the type, or class of the task.</p><p>Implementing your own custom task class in Gradle is easy. You can implement a custom task class in pretty much any language you like, provided it ends up compiled to bytecode. In our examples, we are going to use Groovy as the implementation language. Groovy, Java or Kotlin are all good choices as the language to use to implement a task class, as the Gradle API has been designed to work well with these languages. In general, a task implemented using Java or Kotlin, which are statically typed, will perform better than the same task implemented using Groovy.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:packaging_a_task_class" class="section-anchor" href="#sec:packaging_a_task_class"></a>40.1.&nbsp;Packaging a task class</h2></div></div></div><p>There are several places where you can put the source for the task class.</p><div class="variablelist"><dl><dt><span class="term">Build script</span></dt><dd><p>You can include the task class directly in the build script. This has the benefit that the task class is automatically compiled and included in the classpath of the build script without you having to do anything. However, the task class is not visible outside the build script, and so you cannot reuse the task class outside the build script it is defined in.</p></dd><dt><span class="term"><code class="literal">buildSrc</code> project</span></dt><dd><p>You can put the source for the task class in the <code class="literal"><span class="emphasis"><em>rootProjectDir</em></span>/buildSrc/src/main/groovy</code> directory. Gradle will take care of compiling and testing the task class and making it available on the classpath of the build script. The task class is visible to every build script used by the build. However, it is not visible outside the build, and so you cannot reuse the task class outside the build it is defined in. Using the <code class="literal">buildSrc</code> project approach separates the task declaration - that is, what the task should do - from the task implementation - that is, how the task does it.</p><p>See <a class="xref" href="organizing_build_logic.html">Chapter&nbsp;43, <i>Organizing Build Logic</i></a> for more details about the <code class="literal">buildSrc</code> project.</p></dd><dt><span class="term">Standalone project</span></dt><dd><p>You can create a separate project for your task class. This project produces and publishes a JAR which you can then use in multiple builds and share with others. Generally, this JAR might include some custom plugins, or bundle several related task classes into a single library. Or some combination of the two.</p></dd></dl></div><p>In our examples, we will start with the task class in the build script, to keep things simple. Then we will look at creating a standalone project.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:writing_a_simple_task_class" class="section-anchor" href="#sec:writing_a_simple_task_class"></a>40.2.&nbsp;Writing a simple task class</h2></div></div></div><p>To implement a custom task class, you extend <a class="ulink" href="../dsl/org.gradle.api.DefaultTask.html" target="_top"><code class="classname">DefaultTask</code></a>.</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="customTask"></a><p class="title"><b>Example&nbsp;40.1.&nbsp;Defining a custom task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// ERROR: org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:</span>
build.gradle: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">1</span>: unable to resolve <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> DefaultTask 
 @ line <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">1</span>, column <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">1.</span>
   <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> GreetingTask <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">extends</span> DefaultTask {
   ^

<span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">1</span> error


<span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> GreetingTask <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">extends</span> DefaultTask {
}
</pre></div></div><br class="example-break"><p>This task doesn&rsquo;t do anything useful, so let&rsquo;s add some behaviour. To do so, we add a method to the task and mark it with the <a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskAction.html" target="_top"><code class="classname">TaskAction</code></a> annotation. Gradle will call the method when the task executes. You don&rsquo;t have to use a method to define the behaviour for the task. You could, for instance, call <code class="literal">doFirst()</code> or <code class="literal">doLast()</code> with a closure in the task constructor to add behaviour.</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="customTaskWithAction"></a><p class="title"><b>Example&nbsp;40.2.&nbsp;A hello world task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// ERROR: org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:</span>
build.gradle: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">1</span>: unable to resolve <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> DefaultTask 
 @ line <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">1</span>, column <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">1.</span>
   <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> GreetingTask <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">extends</span> DefaultTask {
   ^

build.gradle: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">2</span>: unable to resolve <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> TaskAction ,  unable to find <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">for</span> annotation
 @ line <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">2</span>, column <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">5.</span>
       <span xmlns:xslthl="http://xslthl.sf.net" class="hl-annotation">@TaskAction</span>
       ^

<span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">2</span> errors


<span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> GreetingTask <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">extends</span> DefaultTask {
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-annotation">@TaskAction</span>
    def greet() {
        println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'hello from GreetingTask'</span>
    }
}

<span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Create a task using the task type</span>
task hello(type: GreetingTask)
</pre><p>Output of <strong class="userinput"><code>gradle -q hello</code></strong></p><pre class="screen">&gt; gradle -q hello
hello from GreetingTask</pre></div></div><br class="example-break"><p>Let&rsquo;s add a property to the task, so we can customize it. Tasks are simply POGOs, and when you declare a task, you can set the properties or call methods on the task object. Here we add a <code class="literal">greeting</code> property, and set the value when we declare the <code class="literal">greeting</code> task.</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="customTaskWithProperty"></a><p class="title"><b>Example&nbsp;40.3.&nbsp;A customizable hello world task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// ERROR: org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:</span>
build.gradle: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">1</span>: unable to resolve <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> DefaultTask 
 @ line <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">1</span>, column <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">1.</span>
   <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> GreetingTask <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">extends</span> DefaultTask {
   ^

build.gradle: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">4</span>: unable to resolve <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> TaskAction ,  unable to find <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">for</span> annotation
 @ line <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">4</span>, column <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">5.</span>
       <span xmlns:xslthl="http://xslthl.sf.net" class="hl-annotation">@TaskAction</span>
       ^

<span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">2</span> errors


<span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> GreetingTask <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">extends</span> DefaultTask {
    String greeting = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'hello from GreetingTask'</span>

    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-annotation">@TaskAction</span>
    def greet() {
        println greeting
    }
}

<span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Use the default greeting</span>
task hello(type: GreetingTask)

<span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Customize the greeting</span>
task greeting(type: GreetingTask) {
    greeting = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'greetings from GreetingTask'</span>
}
</pre><p>Output of <strong class="userinput"><code>gradle -q hello greeting</code></strong></p><pre class="screen">&gt; gradle -q hello greeting
hello from GreetingTask
greetings from GreetingTask</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:custom_tasks_standalone_project" class="section-anchor" href="#sec:custom_tasks_standalone_project"></a>40.3.&nbsp;A standalone project</h2></div></div></div><p>Now we will move our task to a standalone project, so we can publish it and share it with others. This project is simply a Groovy project that produces a JAR containing the task class. Here is a simple build script for the project. It applies the Groovy plugin, and adds the Gradle API as a compile-time dependency.</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="customTaskStandalone"></a><p class="title"><b>Example&nbsp;40.4.&nbsp;A build for a custom task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply(mapOf(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"plugin"</span> to <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"groovy"</span>))
dependencies {
    compile(gradleApi())
    compile(localGroovy())
}</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/customPlugin/plugin</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div></div></div><br class="example-break"><p>We just follow the convention for where the source for the task class should go.</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="customTaskStandalone"></a><p class="title"><b>Example&nbsp;40.5.&nbsp;A custom task</b></p><div class="example-contents"><p><code class="filename">src/main/groovy/org/gradle/GreetingTask.groovy</code></p><pre class="programlisting"><span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">package</span> org.gradle

<span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">import</span> org.gradle.api.DefaultTask
<span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">import</span> org.gradle.api.tasks.TaskAction

<span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> GreetingTask <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">extends</span> DefaultTask {
    String greeting = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'hello from GreetingTask'</span>

    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-annotation">@TaskAction</span>
    def greet() {
        println greeting
    }
}
</pre></div></div><br class="example-break"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:using_your_task_class_in_another_project" class="section-anchor" href="#sec:using_your_task_class_in_another_project"></a>40.3.1.&nbsp;Using your task class in another project</h3></div></div></div><p>To use a task class in a build script, you need to add the class to the build script&rsquo;s classpath. To do this, you use a <code class="literal">buildscript { }</code> block, as described in <a class="xref" href="organizing_build_logic.html#sec:build_script_external_dependencies">Section&nbsp;43.6, &ldquo;External dependencies for the build script&rdquo;</a>. The following example shows how you might do this when the JAR containing the task class has been published to a local repository:</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="usingCustomTask"></a><p class="title"><b>Example&nbsp;40.6.&nbsp;Using a custom task in another project</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">buildscript {
    repositories {
        maven {
            url(uri(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"../repo"</span>))
        }
    }
    dependencies {
        classpath(mapOf(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"group"</span> to <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.gradle"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"name"</span> to <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"customPlugin"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"version"</span> to <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"1.0-SNAPSHOT"</span>))
    }
}
val greeting by tasks.creating {
    type(org.gradle.GreetingTask)
    greeting = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"howdy!"</span>
}</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:writing_tests_for_your_task_class" class="section-anchor" href="#sec:writing_tests_for_your_task_class"></a>40.3.2.&nbsp;Writing tests for your task class</h3></div></div></div><p>You can use the <a class="ulink" href="../javadoc/org/gradle/testfixtures/ProjectBuilder.html" target="_top"><code class="classname">ProjectBuilder</code></a> class to create <a class="ulink" href="../dsl/org.gradle.api.Project.html" target="_top"><code class="classname">Project</code></a> instances to use when you test your task class.</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="customTaskStandalone"></a><p class="title"><b>Example&nbsp;40.7.&nbsp;Testing a custom task</b></p><div class="example-contents"><p><code class="filename">src/test/groovy/org/gradle/GreetingTaskTest.groovy</code></p><pre class="programlisting"><span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> GreetingTaskTest {
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-annotation">@Test</span>
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">public</span> <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">void</span> canAddTaskToProject() {
        Project project = ProjectBuilder.builder().build()
        def task = project.task(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'greeting'</span>, type: GreetingTask)
        assertTrue(task <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">instanceof</span> GreetingTask)
    }
}
</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="incremental_tasks" class="section-anchor" href="#incremental_tasks"></a>40.4.&nbsp;Incremental tasks</h2></div></div></div><div class="note"><p>Incremental tasks are an <a class="link" href="feature_lifecycle.html">incubating</a> feature.</p><p>Since the introduction of the implementation described above (early in the Gradle 1.6 release cycle), discussions within the Gradle community have produced superior ideas for exposing the information about changes to task implementors to what is described below. As such, the API for this feature will almost certainly change in upcoming releases. However, please do experiment with the current implementation and share your experiences with the Gradle community.</p><p>The feature incubation process, which is part of the Gradle feature lifecycle (see <a class="xref" href="feature_lifecycle.html">Appendix&nbsp;C, <i>The Feature Lifecycle</i></a>), exists for this purpose of ensuring high quality final implementations through incorporation of early user feedback.</p></div><p>With Gradle, it&rsquo;s very simple to implement a task that is skipped when all of its inputs and outputs are up to date (see <a class="xref" href="more_about_tasks.html#sec:up_to_date_checks">Section&nbsp;19.10, &ldquo;Up-to-date checks (AKA Incremental Build)&rdquo;</a>). However, there are times when only a few input files have changed since the last execution, and you&rsquo;d like to avoid reprocessing all of the unchanged inputs. This can be particularly useful for a transformer task, that converts input files to output files on a 1:1 basis.</p><p>If you&rsquo;d like to optimise your build so that only out-of-date inputs are processed, you can do so with an <span class="emphasis"><em>incremental task</em></span>.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:implementing_an_incremental_task" class="section-anchor" href="#sec:implementing_an_incremental_task"></a>40.4.1.&nbsp;Implementing an incremental task</h3></div></div></div><p>For a task to process inputs incrementally, that task must contain an <span class="emphasis"><em>incremental task action</em></span>. This is a task action method that contains a single <a class="ulink" href="../dsl/org.gradle.api.tasks.incremental.IncrementalTaskInputs.html" target="_top"><code class="classname">IncrementalTaskInputs</code></a> parameter, which indicates to Gradle that the action will process the changed inputs only.</p><p>The incremental task action may supply an <a class="ulink" href="../dsl/org.gradle.api.tasks.incremental.IncrementalTaskInputs.html#org.gradle.api.tasks.incremental.IncrementalTaskInputs:outOfDate(org.gradle.api.Action)" target="_top"><code class="classname">IncrementalTaskInputs.outOfDate(org.gradle.api.Action)</code></a> action for processing any input file that is out-of-date, and a <a class="ulink" href="../dsl/org.gradle.api.tasks.incremental.IncrementalTaskInputs.html#org.gradle.api.tasks.incremental.IncrementalTaskInputs:removed(org.gradle.api.Action)" target="_top"><code class="classname">IncrementalTaskInputs.removed(org.gradle.api.Action)</code></a> action that executes for any input file that has been removed since the previous execution.</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="taskDefinition"></a><p class="title"><b>Example&nbsp;40.8.&nbsp;Defining an incremental task action</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// ERROR: org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:</span>
build.gradle: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">1</span>: unable to resolve <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> DefaultTask 
 @ line <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">1</span>, column <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">1.</span>
   <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> IncrementalReverseTask <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">extends</span> DefaultTask {
   ^

build.gradle: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">2</span>: unable to resolve <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> InputDirectory ,  unable to find <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">for</span> annotation
 @ line <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">2</span>, column <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">5.</span>
       <span xmlns:xslthl="http://xslthl.sf.net" class="hl-annotation">@InputDirectory</span>
       ^

build.gradle: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">5</span>: unable to resolve <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> OutputDirectory ,  unable to find <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">for</span> annotation
 @ line <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">5</span>, column <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">5.</span>
       <span xmlns:xslthl="http://xslthl.sf.net" class="hl-annotation">@OutputDirectory</span>
       ^

build.gradle: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">8</span>: unable to resolve <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> Input ,  unable to find <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">for</span> annotation
 @ line <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">8</span>, column <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">5.</span>
       <span xmlns:xslthl="http://xslthl.sf.net" class="hl-annotation">@Input</span>
       ^

build.gradle: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">12</span>: unable to resolve <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> IncrementalTaskInputs 
 @ line <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">12</span>, column <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">18.</span>
       <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">void</span> execute(IncrementalTaskInputs inputs) {
                    ^

build.gradle: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">11</span>: unable to resolve <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> TaskAction ,  unable to find <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">for</span> annotation
 @ line <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">11</span>, column <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">5.</span>
       <span xmlns:xslthl="http://xslthl.sf.net" class="hl-annotation">@TaskAction</span>
       ^

<span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">6</span> errors


<span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> IncrementalReverseTask <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">extends</span> DefaultTask {
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-annotation">@InputDirectory</span>
    def File inputDir

    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-annotation">@OutputDirectory</span>
    def File outputDir

    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-annotation">@Input</span>
    def inputProperty

    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-annotation">@TaskAction</span>
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">void</span> execute(IncrementalTaskInputs inputs) {
        println inputs.incremental ? <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'CHANGED inputs considered out of date'</span>
                                   : <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'ALL inputs considered out of date'</span>
        <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (!inputs.incremental)
            project.delete(outputDir.listFiles())

        inputs.outOfDate { change -&gt;
            println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"out of date: ${change.file.name}"</span>
            def targetFile = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">new</span> File(outputDir, change.file.name)
            targetFile.text = change.file.text.reverse()
        }

        inputs.removed { change -&gt;
            println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"removed: ${change.file.name}"</span>
            def targetFile = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">new</span> File(outputDir, change.file.name)
            targetFile.delete()
        }
    }
}
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/userguide/tasks/incrementalTask</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div></div></div><br class="example-break"><p>If for some reason the task is not run incremental, e.g. by running with <code class="literal">--rerun-tasks</code>, only the outOfDate action is executed, even if there were deleted input files. You should consider handling this case at the beginning, as is done in the example above.</p><p>For a simple transformer task like this, the task action simply needs to generate output files for any out-of-date inputs, and delete output files for any removed inputs.</p><p>A task may only contain a single incremental task action.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:which_inputs_are_considered_out_of_date" class="section-anchor" href="#sec:which_inputs_are_considered_out_of_date"></a>40.4.2.&nbsp;Which inputs are considered out of date?</h3></div></div></div><p>When Gradle has history of a previous task execution, and the only changes to the task execution context since that execution are to input files, then Gradle is able to determine which input files need to be reprocessed by the task. In this case, the <a class="ulink" href="../dsl/org.gradle.api.tasks.incremental.IncrementalTaskInputs.html#org.gradle.api.tasks.incremental.IncrementalTaskInputs:outOfDate(org.gradle.api.Action)" target="_top"><code class="classname">IncrementalTaskInputs.outOfDate(org.gradle.api.Action)</code></a> action will be executed for any input file that was <span class="emphasis"><em>added</em></span> or <span class="emphasis"><em>modified</em></span>, and the <a class="ulink" href="../dsl/org.gradle.api.tasks.incremental.IncrementalTaskInputs.html#org.gradle.api.tasks.incremental.IncrementalTaskInputs:removed(org.gradle.api.Action)" target="_top"><code class="classname">IncrementalTaskInputs.removed(org.gradle.api.Action)</code></a> action will be executed for any <span class="emphasis"><em>removed</em></span> input file.</p><p>However, there are many cases where Gradle is unable to determine which input files need to be reprocessed. Examples include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>There is no history available from a previous execution.</p></li><li class="listitem"><p>You are building with a different version of Gradle. Currently, Gradle does not use task history from a different version.</p></li><li class="listitem"><p>An <code class="literal">upToDateWhen</code> criteria added to the task returns <code class="literal">false</code>.</p></li><li class="listitem"><p>An input property has changed since the previous execution.</p></li><li class="listitem"><p>One or more output files have changed since the previous execution.</p></li></ul></div><p>In any of these cases, Gradle will consider all of the input files to be <code class="literal">outOfDate</code>. The <a class="ulink" href="../dsl/org.gradle.api.tasks.incremental.IncrementalTaskInputs.html#org.gradle.api.tasks.incremental.IncrementalTaskInputs:outOfDate(org.gradle.api.Action)" target="_top"><code class="classname">IncrementalTaskInputs.outOfDate(org.gradle.api.Action)</code></a> action will be executed for every input file, and the <a class="ulink" href="../dsl/org.gradle.api.tasks.incremental.IncrementalTaskInputs.html#org.gradle.api.tasks.incremental.IncrementalTaskInputs:removed(org.gradle.api.Action)" target="_top"><code class="classname">IncrementalTaskInputs.removed(org.gradle.api.Action)</code></a> action will not be executed at all.</p><p>You can check if Gradle was able to determine the incremental changes to input files with <a class="ulink" href="../dsl/org.gradle.api.tasks.incremental.IncrementalTaskInputs.html#org.gradle.api.tasks.incremental.IncrementalTaskInputs:incremental" target="_top"><code class="classname">IncrementalTaskInputs.isIncremental()</code></a>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:an_incremental_task_in_action" class="section-anchor" href="#sec:an_incremental_task_in_action"></a>40.4.3.&nbsp;An incremental task in action</h3></div></div></div><p>Given the incremental task implementation <a class="link" href="custom_tasks.html#taskDefinition" title="Example&nbsp;40.8.&nbsp;Defining an incremental task action">above</a>, we can explore the various change scenarios by example. Note that the various mutation tasks ('updateInputs', 'removeInput', etc) are only present for demonstration purposes: these would not normally be part of your build script.</p><p>First, consider the <code class="literal">IncrementalReverseTask</code> executed against a set of inputs for the first time. In this case, all inputs will be considered &ldquo;out of date&rdquo;:</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="incrementalTaskFirstRun"></a><p class="title"><b>Example&nbsp;40.9.&nbsp;Running the incremental task for the first time</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// ERROR: kotlin.NotImplementedError: An operation is not implemented: visitShortTernaryExpression</span>

task incrementalReverse(type: IncrementalReverseTask) {
    inputDir = file(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'inputs'</span>)
    outputDir = file(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"$buildDir/outputs"</span>)
    inputProperty = project.properties[<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskInputProperty'</span>] ?: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'original'</span>
}
</pre><p>Build layout</p><pre class="programlisting">incrementalTask/
  build.gradle
  inputs/
    1.txt
    2.txt
    3.txt
</pre><p>Output of <strong class="userinput"><code>gradle -q incrementalReverse</code></strong></p><pre class="screen">&gt; gradle -q incrementalReverse
ALL inputs considered out of date
out of date: 1.txt
out of date: 2.txt
out of date: 3.txt</pre></div></div><br class="example-break"><p>Naturally when the task is executed again with no changes, then the entire task is up to date and no files are reported to the task action:</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="incrementalTaskNoChange"></a><p class="title"><b>Example&nbsp;40.10.&nbsp;Running the incremental task with unchanged inputs</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle -q incrementalReverse</code></strong></p><pre class="screen">&gt; gradle -q incrementalReverse
</pre></div></div><br class="example-break"><p>When an input file is modified in some way or a new input file is added, then re-executing the task results in those files being reported to <a class="ulink" href="../dsl/org.gradle.api.tasks.incremental.IncrementalTaskInputs.html#org.gradle.api.tasks.incremental.IncrementalTaskInputs:outOfDate(org.gradle.api.Action)" target="_top"><code class="classname">IncrementalTaskInputs.outOfDate(org.gradle.api.Action)</code></a>:</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="incrementalTaskUpdatedInputs"></a><p class="title"><b>Example&nbsp;40.11.&nbsp;Running the incremental task with updated input files</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">val updateInputs by tasks.creating {
    doLast {
        file(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"inputs/1.txt"</span>).text = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"Changed content for existing file 1."</span>
        file(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"inputs/4.txt"</span>).text = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"Content for new file 4."</span>
    }
}</pre><p>Output of <strong class="userinput"><code>gradle -q updateInputs incrementalReverse</code></strong></p><pre class="screen">&gt; gradle -q updateInputs incrementalReverse
CHANGED inputs considered out of date
out of date: 1.txt
out of date: 4.txt</pre></div></div><br class="example-break"><p>When an existing input file is removed, then re-executing the task results in that file being reported to <a class="ulink" href="../dsl/org.gradle.api.tasks.incremental.IncrementalTaskInputs.html#org.gradle.api.tasks.incremental.IncrementalTaskInputs:removed(org.gradle.api.Action)" target="_top"><code class="classname">IncrementalTaskInputs.removed(org.gradle.api.Action)</code></a>:</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="incrementalTaskRemovedInput"></a><p class="title"><b>Example&nbsp;40.12.&nbsp;Running the incremental task with an input file removed</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">val removeInput by tasks.creating {
    doLast {
        delete()
    }
}</pre><p>Output of <strong class="userinput"><code>gradle -q removeInput incrementalReverse</code></strong></p><pre class="screen">&gt; gradle -q removeInput incrementalReverse
CHANGED inputs considered out of date
removed: 3.txt</pre></div></div><br class="example-break"><p>When an output file is deleted (or modified), then Gradle is unable to determine which input files are out of date. In this case, <span class="emphasis"><em>all</em></span> input files are reported to the <a class="ulink" href="../dsl/org.gradle.api.tasks.incremental.IncrementalTaskInputs.html#org.gradle.api.tasks.incremental.IncrementalTaskInputs:outOfDate(org.gradle.api.Action)" target="_top"><code class="classname">IncrementalTaskInputs.outOfDate(org.gradle.api.Action)</code></a> action, and no input files are reported to the <a class="ulink" href="../dsl/org.gradle.api.tasks.incremental.IncrementalTaskInputs.html#org.gradle.api.tasks.incremental.IncrementalTaskInputs:removed(org.gradle.api.Action)" target="_top"><code class="classname">IncrementalTaskInputs.removed(org.gradle.api.Action)</code></a> action:</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="incrementalTaskRemovedOutput"></a><p class="title"><b>Example&nbsp;40.13.&nbsp;Running the incremental task with an output file removed</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">val removeOutput by tasks.creating {
    doLast {
        delete()
    }
}</pre><p>Output of <strong class="userinput"><code>gradle -q removeOutput incrementalReverse</code></strong></p><pre class="screen">&gt; gradle -q removeOutput incrementalReverse
ALL inputs considered out of date
out of date: 1.txt
out of date: 2.txt
out of date: 3.txt</pre></div></div><br class="example-break"><p>When a task input property is modified, Gradle is unable to determine how this property impacted the task outputs, so all input files are assumed to be out of date. So similar to the changed output file example, <span class="emphasis"><em>all</em></span> input files are reported to the <a class="ulink" href="../dsl/org.gradle.api.tasks.incremental.IncrementalTaskInputs.html#org.gradle.api.tasks.incremental.IncrementalTaskInputs:outOfDate(org.gradle.api.Action)" target="_top"><code class="classname">IncrementalTaskInputs.outOfDate(org.gradle.api.Action)</code></a> action, and no input files are reported to the <a class="ulink" href="../dsl/org.gradle.api.tasks.incremental.IncrementalTaskInputs.html#org.gradle.api.tasks.incremental.IncrementalTaskInputs:removed(org.gradle.api.Action)" target="_top"><code class="classname">IncrementalTaskInputs.removed(org.gradle.api.Action)</code></a> action:</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="incrementalTaskChangedProperty"></a><p class="title"><b>Example&nbsp;40.14.&nbsp;Running the incremental task with an input property changed</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle -q -PtaskInputProperty=changed incrementalReverse</code></strong></p><pre class="screen">&gt; gradle -q -PtaskInputProperty=changed incrementalReverse
ALL inputs considered out of date
out of date: 1.txt
out of date: 2.txt
out of date: 3.txt</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="worker_api" class="section-anchor" href="#worker_api"></a>40.5.&nbsp;The Worker API</h2></div></div></div><div class="note"><p>The Worker API is an <a class="link" href="feature_lifecycle.html">incubating</a> feature.</p></div><p>As can be seen from the discussion of <a class="link" href="custom_tasks.html#incremental_tasks">incremental tasks</a>, the work that a task performs can be viewed as discrete units (i.e. a subset of inputs that are transformed to a certain subset of outputs). Many times, these units of work are highly independent of each other, meaning they can be performed in any order and simply aggregated together to form the overall action of the task. In a single threaded execution, these units of work would execute in sequence, however if we have multiple processors, it would be desirable to perform independent units of work concurrently. By doing so, we can fully utilize the available resources at build time and complete the activity of the task faster.</p><p>The Worker API provides a mechanism for doing exactly this. It allows for safe, concurrent execution of multiple items of work during a task action. But the benefits of the Worker API are not confined to parallelizing the work of a task. You can also configure a desired level of isolation such that work can be executed in an isolated classloader or even in an isolated process. Furthermore, the benefits extend beyond even the execution of a single task. Using the Worker API, Gradle can begin to execute tasks in parallel by default. In other words, once a task has submitted its work to be executed asynchronously, and has exited the task action, Gradle can then begin the execution of other independent tasks in parallel, even if those tasks are in the same project.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="using-the-worker-api" class="section-anchor" href="#using-the-worker-api"></a>40.5.1.&nbsp;Using the Worker API</h3></div></div></div><p>In order to submit work to the Worker API, two things must be provided: an implementation of the unit of work, and a configuration for the unit of work. The implementation is simply a class that extends <code class="literal">java.lang.Runnable</code>. This class should have a constructor that is annotated with <code class="literal">javax.inject.Inject</code> and accepts parameters that configure the class for a single unit of work. When a unit of work is submitted to the <a class="ulink" href="../javadoc/org/gradle/workers/WorkerExecutor.html" target="_top"><code class="classname">WorkerExecutor</code></a>, an instance of this class will be created and the parameters configured for the unit of work will be passed to the constructor.</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="unitOfWork"></a><p class="title"><b>Example&nbsp;40.15.&nbsp;Creating a unit of work implementation</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">destinationFile.text = reverse()</pre></div></div><br class="example-break"><p>The configuration of the worker is represented by a <a class="ulink" href="../javadoc/org/gradle/workers/WorkerConfiguration.html" target="_top"><code class="classname">WorkerConfiguration</code></a> and is set by configuring an instance of this object at the time of submission. However, in order to submit the unit of work, it is necessary to first acquire the <a class="ulink" href="../javadoc/org/gradle/workers/WorkerExecutor.html" target="_top"><code class="classname">WorkerExecutor</code></a>. To do this, a constructor should be provided that is annotated with <code class="literal">javax.inject.Inject</code> and accepts a <a class="ulink" href="../javadoc/org/gradle/workers/WorkerExecutor.html" target="_top"><code class="classname">WorkerExecutor</code></a> parameter. Gradle will inject the instance of <a class="ulink" href="../javadoc/org/gradle/workers/WorkerExecutor.html" target="_top"><code class="classname">WorkerExecutor</code></a> at runtime when the task is created.</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="workSubmission"></a><p class="title"><b>Example&nbsp;40.16.&nbsp;Submitting a unit of work for execution</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// ERROR: org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:</span>
build.gradle: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">1</span>: unable to resolve <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> SourceTask 
 @ line <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">1</span>, column <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">1.</span>
   <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> ReverseFiles <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">extends</span> SourceTask {
   ^

build.gradle: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">2</span>: unable to resolve <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> WorkerExecutor 
 @ line <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">2</span>, column <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">5.</span>
       <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">final</span> WorkerExecutor workerExecutor
       ^

build.gradle: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">4</span>: unable to resolve <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> OutputDirectory ,  unable to find <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">for</span> annotation
 @ line <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">4</span>, column <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">5.</span>
       <span xmlns:xslthl="http://xslthl.sf.net" class="hl-annotation">@OutputDirectory</span>
       ^

build.gradle: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">9</span>: unable to resolve <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> WorkerExecutor 
 @ line <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">9</span>, column <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">25.</span>
       <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">public</span> ReverseFiles(WorkerExecutor workerExecutor) {
                           ^

build.gradle: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">8</span>: unable to resolve <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> Inject ,  unable to find <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">for</span> annotation
 @ line <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">8</span>, column <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">5.</span>
       <span xmlns:xslthl="http://xslthl.sf.net" class="hl-annotation">@Inject</span>
       ^

build.gradle: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">13</span>: unable to resolve <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> TaskAction ,  unable to find <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">for</span> annotation
 @ line <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">13</span>, column <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">5.</span>
       <span xmlns:xslthl="http://xslthl.sf.net" class="hl-annotation">@TaskAction</span>
       ^

build.gradle: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">17</span>: unable to resolve <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> WorkerConfiguration 
 @ line <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">17</span>, column <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">54.</span>
   tor.submit(ReverseFile.<span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span>) { WorkerCo
                                 ^

<span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">7</span> errors


<span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> ReverseFiles <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">extends</span> SourceTask {
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">final</span> WorkerExecutor workerExecutor

    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-annotation">@OutputDirectory</span>
    File outputDir

    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// The WorkerExecutor will be injected by Gradle at runtime</span>
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-annotation">@Inject</span>
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">public</span> ReverseFiles(WorkerExecutor workerExecutor) {
        <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">this</span>.workerExecutor = workerExecutor
    }

    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-annotation">@TaskAction</span>
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">void</span> reverseFiles() {
        <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Create and submit a unit of work for each file</span>
        source.files.each { file -&gt;
            workerExecutor.submit(ReverseFile.<span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span>) { WorkerConfiguration config -&gt;
                <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Use the minimum level of isolation</span>
                config.isolationMode = IsolationMode.NONE

                <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Constructor parameters for the unit of work implementation</span>
                config.params file, project.file(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"${outputDir}/${file.name}"</span>)
            }
        }
    }
}
</pre></div></div><br class="example-break"><p>Note that one element of the <a class="ulink" href="../javadoc/org/gradle/workers/WorkerConfiguration.html" target="_top"><code class="classname">WorkerConfiguration</code></a> is the <code class="literal">params</code> property. These are the parameters passed to the constructor of the unit of work implementation for each item of work submitted. Any parameters provided to the unit of work <span class="emphasis"><em>must</em></span> be <code class="literal">java.io.Serializable</code>.</p><p>Once all of the work for a task action has been submitted, it is safe to exit the task action. The work will be executed asynchronously and in parallel (up to the setting of <code class="literal">max-workers</code>). Of course, any tasks that are dependent on this task (and any subsequent task actions of this task) will not begin executing until all of the asynchronous work completes. However, other independent tasks that have no relationship to this task can begin executing immediately.</p><p>If any failures occur while executing the asynchronous work, the task will fail and a <a class="ulink" href="../javadoc/org/gradle/workers/WorkerExecutionException.html" target="_top"><code class="classname">WorkerExecutionException</code></a> will be thrown detailing the failure for each failed work item. This will be treated like any failure during task execution and will prevent any dependent tasks from executing.</p><p>In some cases, however, it might be desirable to wait for work to complete before exiting the task action. This is possible using the <a class="ulink" href="../javadoc/org/gradle/workers/WorkerExecutor.html#await()" target="_top"><code class="classname">WorkerExecutor.await()</code></a> method. As in the case of allowing the work to complete asynchronously, any failures that occur while executing an item of work will be surfaced as a <a class="ulink" href="../javadoc/org/gradle/workers/WorkerExecutionException.html" target="_top"><code class="classname">WorkerExecutionException</code></a> thrown from the <a class="ulink" href="../javadoc/org/gradle/workers/WorkerExecutor.html#await()" target="_top"><code class="classname">WorkerExecutor.await()</code></a> method.</p><div class="note"><p>Note that Gradle will only begin running other independent tasks in parallel when a task has exited a task action and returned control of execution to Gradle. When <a class="ulink" href="../javadoc/org/gradle/workers/WorkerExecutor.html#await()" target="_top"><code class="classname">WorkerExecutor.await()</code></a> is used, execution does not leave the task action. This means that Gradle will not allow other tasks to begin executing and will wait for the task action to complete before doing so.</p></div><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="waitForCompletion"></a><p class="title"><b>Example&nbsp;40.17.&nbsp;Waiting for asynchronous work to complete</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">each {
    submit(ReverseFile.<span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span>) {
        config.isolationMode = IsolationMode.NONE
        params(file, file(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"$outputDir/${file.name}"</span>))
    }
}
await()
lifecycle(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"Created ${size()} reversed files in ${relativePath(outputDir)}"</span>)</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="isolation-modes" class="section-anchor" href="#isolation-modes"></a>40.5.2.&nbsp;Isolation Modes</h3></div></div></div><p>Gradle provides three isolation modes that can be configured on a unit of work and are specified using the <a class="ulink" href="../javadoc/org/gradle/workers/IsolationMode.html" target="_top"><code class="classname">IsolationMode</code></a> enum:</p><div class="variablelist"><dl><dt><span class="term">IsolationMode.NONE</span></dt><dd><p>This states that the work should be run in a thread with a minimum of isolation. For instance, it will share the same classloader that the task is loaded from. This is the fastest level of isolation.</p></dd><dt><span class="term">IsolationMode.CLASSLOADER</span></dt><dd><p>This states that the work should be run in a thread with an isolated classloader. The classloader will have the classpath from the classloader that the unit of work implementation class was loaded from as well as any additional classpath entries added through <a class="ulink" href="../javadoc/org/gradle/workers/WorkerConfiguration.html#classpath(java.lang.Iterable)" target="_top"><code class="classname">WorkerConfiguration.classpath(java.lang.Iterable)</code></a>.</p></dd><dt><span class="term">IsolationMode.PROCESS</span></dt><dd><p>This states that the work should be run with a maximum level of isolation by executing the work in a separate process. The classloader of the process will use the classpath from the classloader that the unit of work was loaded from as well as any additional classpath entries added through <a class="ulink" href="../javadoc/org/gradle/workers/WorkerConfiguration.html#classpath(java.lang.Iterable)" target="_top"><code class="classname">WorkerConfiguration.classpath(java.lang.Iterable)</code></a>. Furthermore, the process will be a <span class="emphasis"><em>Worker Daemon</em></span> which will stay alive and can be reused for future work items that may have the same requirements. This process can be configured with different settings than the Gradle JVM using <a class="ulink" href="../javadoc/org/gradle/workers/WorkerConfiguration.html#forkOptions(org.gradle.api.Action)" target="_top"><code class="classname">WorkerConfiguration.forkOptions(org.gradle.api.Action)</code></a>.</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="worker-daemons" class="section-anchor" href="#worker-daemons"></a>40.5.3.&nbsp;Worker Daemons</h3></div></div></div><p>When using <code class="literal">IsolationMode.PROCESS</code>, gradle will start a long-lived <span class="emphasis"><em>Worker Daemon</em></span> process that can be reused for future work items.</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="workerDaemon"></a><p class="title"><b>Example&nbsp;40.18.&nbsp;Submitting an item of work to run in a worker daemon</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// ERROR: org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:</span>
build.gradle: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">1</span>: unable to resolve <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> WorkerConfiguration 
 @ line <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">1</span>, column <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">54.</span>
   tor.submit(ReverseFile.<span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span>) { WorkerCo
                                 ^

build.gradle: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">6</span>: unable to resolve <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> JavaForkOptions 
 @ line <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">6</span>, column <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">36.</span>
                   config.forkOptions { JavaForkOptions options -&gt;
                                      ^

<span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">2</span> errors


            workerExecutor.submit(ReverseFile.<span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span>) { WorkerConfiguration config -&gt;
                <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Run this work in an isolated process</span>
                config.isolationMode = IsolationMode.PROCESS

                <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Configure the options for the forked process</span>
                config.forkOptions { JavaForkOptions options -&gt;
                    options.maxHeapSize = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"512m"</span>
                    options.systemProperty <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.gradle.sample.showFileSize"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"true"</span>
                }

                <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Constructor parameters for the unit of work implementation</span>
                config.params file, project.file(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"${outputDir}/${file.name}"</span>)
            }
</pre></div></div><br class="example-break"><p>When a unit of work for a Worker Daemon is submitted, Gradle will first look to see if a compatible, idle daemon already exists. If so, it will send the unit of work to the idle daemon, marking it as busy. If not, it will start a new daemon. When evaluating compatibility, Gradle looks at a number of criteria, all of which can be controlled through <a class="ulink" href="../javadoc/org/gradle/workers/WorkerConfiguration.html#forkOptions(org.gradle.api.Action)" target="_top"><code class="classname">WorkerConfiguration.forkOptions(org.gradle.api.Action)</code></a>.</p><div class="variablelist"><dl><dt><span class="term">executable</span></dt><dd><p>A daemon is considered compatible only if it uses the same java executable.</p></dd><dt><span class="term">classpath</span></dt><dd><p>A daemon is considered compatible if its classpath contains all of the classpath entries requested. Note that a daemon is considered compatible if it has more classpath entries in addition to those requested.</p></dd><dt><span class="term">heap settings</span></dt><dd><p>A daemon is considered compatible if it has at least the same heap size settings as requested. In other words, a daemon that has higher heap settings than requested would be considered compatible.</p></dd><dt><span class="term">jvm arguments</span></dt><dd><p>A daemon is considered compatible if it has set all of the jvm arguments requested. Note that a daemon is considered compatible if it has additional jvm arguments beyond those requested (except for arguments treated specially such as heap settings, assertions, debug, etc).</p></dd><dt><span class="term">system properties</span></dt><dd><p>A daemon is considered compatible if it has set all of the system properties requested with the same values. Note that a daemon is considered compatible if it has additional system properties beyond those requested.</p></dd><dt><span class="term">environment variables</span></dt><dd><p>A daemon is considered compatible if it has set all of the environment variables requested with the same values. Note that a daemon is considered compatible if it has more environment variables in addition to those requested.</p></dd><dt><span class="term">bootstrap classpath</span></dt><dd><p>A daemon is considered compatible if it contains all of the bootstrap classpath entries requested. Note that a daemon is considered compatible if it has more bootstrap classpath entries in addition to those requested.</p></dd><dt><span class="term">debug</span></dt><dd><p>A daemon is considered compatible only if debug is set to the same value as requested (true or false).</p></dd><dt><span class="term">enable assertions</span></dt><dd><p>A daemon is considered compatible only if enable assertions is set to the same value as requested (true or false).</p></dd><dt><span class="term">default character encoding</span></dt><dd><p>A daemon is considered compatible only if the default character encoding is set to the same value as requested.</p></dd></dl></div><p>Worker daemons will remain running until either the build daemon that started them is stopped, or system memory becomes scarce. When available system memory is low, Gradle will begin stopping worker daemons in an attempt to minimize memory consumption.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:reusing_task_logic" class="section-anchor" href="#sec:reusing_task_logic"></a>40.6.&nbsp;Re-using logic between task classes</h2></div></div></div><p>There are different ways to re-use logic between task classes.
The easiest case is when you can extract the logic you want to share in a separate method or class and then use the extracted piece of code in your tasks.
For example, the <a class="ulink" href="../dsl/org.gradle.api.tasks.Copy.html" target="_top"><code class="classname">Copy</code></a> task re-uses the logic of the <a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:copy(org.gradle.api.Action)" target="_top"><code class="classname">Project.copy(org.gradle.api.Action)</code></a> method.
Another option is to add a task dependency on the task which outputs you want to re-use.
Other options include using <a class="link" href="more_about_tasks.html#sec:task_rules">task rules</a> or the <a class="link" href="custom_tasks.html#worker_api">worker API</a>.</p></div></div><div class="navfooter"><div><div class="navbar"><a xmlns:xslthl="http://xslthl.sf.net" href="pt04.html" title="Part&nbsp;IV.&nbsp;Extending the build">Previous</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="userguide.html" title="Gradle User Guide Version 4.3-20171005220000+0000">Contents</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="custom_plugins.html" title="Writing Custom Plugins - Gradle User Guide Version 4.3-20171005220000+0000">Next</a></div></div></div></body></html>